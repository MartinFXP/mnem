---
title: "Micture Nested Effects Models  \n
Inferring networks from sub-populations of single cells."
author: "Martin Pirkl, Niko Beerenwinkel"
date: "`r Sys.Date()`"
graphics: yes
output: BiocStyle::pdf_document
vignette: >
    %\VignetteIndexEntry{mnem}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

	# M&NEM

  Single cell RNA-seq data sets from pooled CrispR screens provide the possibility to analyzse heterogeneous cell populations. We extended the original Nested Effects Models (NEM) to Mixture Nested Effects Models (M&NEM) to identify not one causal signalling, but several ones, each based on the information of a sub-population of cells.

  ## Install

  Download and install the package manually or use 'devtools'.

  
```r
install.packages("devtools")

library(devtools)

install_github("cbg-ethz/mnem")

library(mnem)
```
  
## Simulations

  We simulate cells based on a ground truth mixture of networks. We use M&NEM to infer an optimal network from the data and compare the result ot the ground truth.

	```{r, eval = FALSE}

runs <- 100
maxk <- 5
par(mfrow=c(1,maxk))
mixrand <- matrix(0, runs, maxk)
for (j in 1:5) {
    nem <- j
    tmp <- numeric(runs)
    for (i in 1:runs) {
        mw <- runif(nem, 0.1, 1)
        mw <- mw/sum(mw)
        nem2 <- sample(1:5, 1)
        mw2 <- runif(nem2, 0.1, 1)
        mw2 <- mw2/sum(mw2)
        tmp[i] <- dist(rbind(mw, mw2))
    }
    hist(tmp)
    abline(v=mean(tmp), col = "red")
    abline(v=median(tmp), col = "blue")
    mixrand[, j] <- tmp
}
par(mfrow=c(1,1))

boxplot(mixrand, col = "grey", main = "random", xlab = "components K")

## variable parameters:
runs <- 100
noises <- c(1, 2.5, 5)

acc <- acc2 <- sens <- spec <- mwcor <- numeric(runs)

Sgenes <- 5
Egenes <- 2
nem <- 2
maxk <- 5
starts <- 10
noise <- 1
nCells <- 1000

for (run in 1:length(acc)) {
    mw <- runif(nem, 0.1, 1)
    mw <- mw/sum(mw)
    sim <- simData(Sgenes = Sgenes, Egenes = Egenes, nCells = nCells,
                   Nems = nem, uninform = floor(Egenes*Sgenes*0.1), mw = mw)
    simfull <- NULL
    gtn <- list()
    for (i in 1:length(sim$Nem)) {
        tmp <- transitive.closure(sim$Nem[[i]], mat = TRUE)
        simfull <- cbind(simfull, t(tmp))
        gtn[[i]] <- list()
        gtn[[i]]$adj <- sim$Nem[[i]]
    }
    
    data <- sim$data
    data <- (data - 0.5)/0.5
    data <- data + rnorm(length(sim$data), 0, noises[noise])
    for (i in 1:Sgenes) {
        colnames(data)[which(colnames(data) == i)] <- letters[i]
    }

    start <- Sys.time()
    res2 <- list()
    bics <- rep(Inf, maxk)
    for (k in 1:maxk) {
        res2[[k]] <- mnem(data, starts = starts, k = k)
        bics[k] <- getIC(res2[[k]])
    }
    res <- res2[[which.min(bics)]]
    end <- Sys.time()
    print(end - start)
    
    resfull <- NULL
    for (i in 1:length(res$comp)) {
        tmp <- transitive.closure(res$comp[[i]]$phi, mat = TRUE)
        resfull <- cbind(resfull, t(tmp))
    }
    
    resadj <- list()
    for (i in 1:length(res$comp)) {
        resadj[[i]] <- list()
        resadj[[i]]$adj <- res$comp[[i]]$phi
    }
    acc[run] <- hamSim(resfull, simfull, symmetric = TRUE)
}

```

	We randomly draw mixture weights as a comparison to our inferred weights.
	
	```r
 
runs <- 100
maxk <- 5
mixrand <- matrix(0, runs, maxk)
for (j in 1:5) {
    nem <- j
    tmp <- numeric(runs)
    for (i in 1:runs) {
        mw <- runif(nem, 0.1, 1)
        mw <- mw/sum(mw)
        nem2 <- sample(1:5, 1)
        mw2 <- runif(nem2, 0.1, 1)
        mw2 <- mw2/sum(mw2)
        tmp[i] <- dist(rbind(mw, mw2))
    }
    mixrand[, j] <- tmp
}

boxplot(mixrand, col = "grey", main = "random", xlab = "components K")
```
	
Evaluation of the simulation results by accuracy of the networks, mixture weights and number of components.

	   ```r

    data(sim)
  
meancol2 <- rgb(1,0,0)

meancol <- rgb(0,0,1)

redcol <- rgb(1,0,0)

bluecol <- rgb(0,0,1)

mar <- 1.5

par(mfrow=c(5,4),mar=rep(mar, 4),oma=c(3,5,3,0))

for (i in 1:5) {
    for (j in c(3,5,10,20)) {
        tmp <- get(paste0("simres", j))
        tmp2 <- NULL
        for (k in c(1,2)) {
            for (l in 1:3) {
                tmp3 <- tmp[,l,i,k,3]
                #tmp3[which(tmp3 == 0)] <- mean(tmp3[which(tmp3 != 0)])
                tmp2 <- cbind(tmp2, tmp3)
            }
        }
        boxplot(tmp2, col = c(rep(redcol, 3), rep(bluecol, 3), rep("grey", 3)), xaxt = "n", ylim = c(0.5,1))
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol)
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol2, pch = "*")
        axis(1, 1:(length(noises)*3), rep(noises, 3))
        ## axis(1, c(length(noises)/2 + 0.5, length(noises)/2*3 + 0.5, length(noises)/2*5 + 0.5), c("mnem", "nem", "random"), line = 2, tick = FALSE, cex = 2)
        ## abline(v=c(length(noises)+0.5, length(noises)*2+0.5), lty = 3, col = "black", lwd = 2)
        abline(v=c(length(noises)+0.5), lty = 3, col = "black", lwd = 2)
    }
}

for (i in 1:5) {
    mtext(paste0("K=", i), side = 3, line = (40 - (i-1)*11.1), outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*4)
}

Sgenes <- c(3,5,10,20)

for (i in 1:4) {
    mtext(paste0("n=", Sgenes[i]), side = 3, line = 46, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.2 - (i-1)*1.2))
}

for (i in 1:4) {
    mtext("NEM", side = 3, line = 44.3, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(2.97 - (i-1)*1.2))
}

for (i in 1:4) {
    mtext("M&NEM", side = 3, line = 44.3, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.5 - (i-1)*1.2))
}

for (i in 1:4) {
    mtext(expression(sigma), side = 3, line = -12, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.1 - (i-1)*1.2))
}

mar <- 1.5

par(mfrow=c(5,4),mar=rep(mar, 4),oma=c(3,5,3,0))

for (i in 1:5) {
    for (j in c(3,5,10,20)) {
        tmp <- get(paste0("simres", j))
        tmp2 <- NULL
        for (l in 1:3) {
            tmp3 <- tmp[,l,i,1,2]
            #tmp3[which(tmp3 == 0)] <- mean(tmp3[which(tmp3 != 0)])
            tmp2 <- cbind(tmp2, tmp3)
        }
        boxplot(tmp2, col = rep(redcol, 3), xaxt = "n")
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol)
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol2, pch = "*")
        axis(1, 1:(length(noises)*3), rep(noises, 3))
        #axis(1, c(length(noises)/2 + 0.5, length(noises)/2*3 + 0.5, length(noises)/2*5 + 0.5), c(paste0(j, " | ", i), "nem", "random"), line = 2, tick = FALSE, cex = 2)
        ## abline(v=c(length(noises)+0.5, length(noises)*2+0.5), lty = 3, col = "black", lwd = 2)
        abline(h=1, lty = 3, col = "black", lwd = 2)
    }
}

for (i in 1:5) {
    mtext(paste0("K=", i), side = 3, line = (40 - (i-1)*11.1), outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*4)
}

Sgenes <- c(3,5,10,20)

for (i in 1:4) {
    mtext(paste0("n=", Sgenes[i]), side = 3, line = 46, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.2 - (i-1)*1.2))
}

for (i in 1:4) {
    mtext(expression(sigma), side = 3, line = -12, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.15 - (i-1)*1.21))
}

par(mfrow=c(5,4),mar=rep(mar, 4),oma=c(3,5,3,0))

for (i in 1:5) {
    for (j in c(3,5,10,20)) {
        tmp <- get(paste0("simres", j))
        tmp2 <- NULL
        for (l in 1:3) {
            tmp3 <- tmp[,l,i,1,6]
            #tmp3[which(tmp3 == 0)] <- mean(tmp3[which(tmp3 != 0)])
            tmp2 <- cbind(tmp2, tmp3)
        }
        boxplot(tmp2, col = rep(redcol, 3), xaxt = "n")
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol)
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol2, pch = "*")
        axis(1, 1:(length(noises)*3), rep(noises, 3))
        #axis(1, c(length(noises)/2 + 0.5, length(noises)/2*3 + 0.5, length(noises)/2*5 + 0.5), c(paste0(j, " | ", i), "nem", "random"), line = 2, tick = FALSE, cex = 2)
        ## abline(v=c(length(noises)+0.5, length(noises)*2+0.5), lty = 3, col = "black", lwd = 2)
        abline(h=1, lty = 3, col = "black", lwd = 2)
    }
}

for (i in 1:5) {
    mtext(paste0("K=", i), side = 3, line = (40 - (i-1)*11.1), outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*4)
}

Sgenes <- c(3,5,10,20)

for (i in 1:4) {
    mtext(paste0("n=", Sgenes[i]), side = 3, line = 46, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.2 - (i-1)*1.2))
}

for (i in 1:4) {
    mtext(expression(sigma), side = 3, line = -12, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.15 - (i-1)*1.21))
}

```
	## Application

	We apply M&NEM to three different data sets from two different pooled CRISPR screens, Crop-Seq (Datlinger **et al.**, 2017) and Perturb-Seq (Dixit **et al.**, 2016).

	