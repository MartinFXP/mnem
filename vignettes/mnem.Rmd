---
title: "Mixture Nested Effects Models  \n
Inferring networks from sub-populations of single cells."
author: "Martin Pirkl, Niko Beerenwinkel"
date: "`r Sys.Date()`"
graphics: yes
output: BiocStyle::pdf_document
vignette: >
    %\VignetteIndexEntry{mnem}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

# Mixture Nested Effects Models (M&NEM)

Single cell RNA-seq data sets from pooled CrispR screens provide the possibility to analyzse heterogeneous cell populations. We extended the original Nested Effects Models (NEM) to Mixture Nested Effects Models (M&NEM) to identify not one causal signalling, but several ones, each based on the information of a sub-population of cells.

## Install

Download and install the package manually or use 'devtools'.

```{r, global_options, include=FALSE}
knitr::opts_chunk$set(message=FALSE)
fig.cap1 <- "Accuracy of the networks and number of components."
fig.cap2 <- "Accuracy of the networks."
fig.cap3 <- "Accuracy for number of components. Greater than 1 means too many were inferred. Less than 1 means to few."
fig.cap4 <- "Distance of inferred to ground truth mixture weights."
```
```{r}
install.packages("devtools")

library(devtools)

install_github("cbg-ethz/mnem")

library(mnem)
```
  
## Simulations

We simulate cells based on a ground truth mixture of networks. We use M&NEM to infer an optimal network from the data and compare the result ot the ground truth.

```{r, eval = FALSE}
runs <- 100
noises <- c(1, 2.5, 5)

acc <- comps <- mws <- numeric(runs)

Sgenes <- 5
Egenes <- 2
nem <- 2
maxk <- 5
starts <- 10
noise <- 1
nCells <- 1000

for (run in 1:length(acc)) {
    mw <- runif(nem, 0.1, 1)
    mw <- mw/sum(mw)
    sim <- simData(Sgenes = Sgenes, Egenes = Egenes, nCells = nCells,
                   Nems = nem, uninform = floor(Egenes*Sgenes*0.1), mw = mw)
    simfull <- NULL
    gtn <- list()
    for (i in 1:length(sim$Nem)) {
        tmp <- transitive.closure(sim$Nem[[i]], mat = TRUE)
        simfull <- cbind(simfull, t(tmp))
        gtn[[i]] <- list()
        gtn[[i]]$adj <- sim$Nem[[i]]
    }
    
    data <- sim$data
    data <- (data - 0.5)/0.5
    data <- data + rnorm(length(sim$data), 0, noises[noise])
    for (i in 1:Sgenes) {
        colnames(data)[which(colnames(data) == i)] <- letters[i]
    }

    start <- Sys.time()
    res2 <- list()
    bics <- rep(Inf, maxk)
    for (k in 1:maxk) {
        res2[[k]] <- mnem(data, starts = starts, k = k)
        bics[k] <- getIC(res2[[k]])
    }
    res <- res2[[which.min(bics)]]
    end <- Sys.time()
    print(end - start)
    comps[run] <- which.min(bics)
    
    resfull <- NULL
    for (i in 1:length(res$comp)) {
        tmp <- transitive.closure(res$comp[[i]]$phi, mat = TRUE)
        resfull <- cbind(resfull, t(tmp))
    }
    
    resadj <- list()
    for (i in 1:length(res$comp)) {
        resadj[[i]] <- list()
        resadj[[i]]$adj <- res$comp[[i]]$phi
    }
    acc[run] <- hamSim(resfull, simfull, symmetric = TRUE)
}
par(mfrow=c(1,2)
plot(acc)
plot(comps)    
```

We randomly draw mixture weights as a comparison to our inferred weights.
	
```{r}
runs <- 100
maxk <- 5
mixrand <- matrix(0, runs, maxk)
for (j in 1:5) {
    nem <- j
    tmp <- numeric(runs)
    for (i in 1:runs) {
        mw <- runif(nem, 0.1, 1)
        mw <- mw/sum(mw)
        nem2 <- sample(1:5, 1)
        mw2 <- runif(nem2, 0.1, 1)
        mw2 <- mw2/sum(mw2)
        tmp[i] <- dist(rbind(mw, mw2))
    }
    mixrand[, j] <- tmp
}

boxplot(mixrand, col = "grey", main = "random", xlab = "components K")
```
	
Evaluation of the simulation results by accuracy of the networks, mixture weights and number of components.

```{r, fig.height=12, fig.width=12, fig.cap=fig.cap2}
data(sim)

simres3 <- sim[[1]]
simres5 <- sim[[2]]
simres10 <- sim[[3]]
simres20 <- sim[[4]]
  
meancol2 <- rgb(1,0,0)

meancol <- rgb(0,0,1)

redcol <- rgb(1,0,0)

bluecol <- rgb(0,0,1)

mar <- 1.5

par(mfrow=c(5,4),mar=rep(mar, 4),oma=c(3,5,3,0))

for (i in 1:5) {
    for (j in c(3,5,10,20)) {
        tmp <- get(paste0("simres", j))
        tmp2 <- NULL
        for (k in c(1,2)) {
            for (l in 1:3) {
                tmp3 <- tmp[,l,i,k,3]
                tmp2 <- cbind(tmp2, tmp3)
            }
        }
        boxplot(tmp2, col = c(rep(redcol, 3), rep(bluecol, 3), rep("grey", 3)), xaxt = "n", ylim = c(0.5,1))
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol)
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol2, pch = "*")
        axis(1, 1:(length(noises)*3), rep(noises, 3))
        abline(v=c(length(noises)+0.5), lty = 3, col = "black", lwd = 2)
    }
}

for (i in 1:5) {
    mtext(paste0("K=", i), side = 3, line = (40 - (i-1)*11.1), outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*4)
}

Sgenes <- c(3,5,10,20)

for (i in 1:4) {
    mtext(paste0("n=", Sgenes[i]), side = 3, line = 46, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.2 - (i-1)*1.2))
}

for (i in 1:4) {
    mtext("NEM", side = 3, line = 44.3, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(2.97 - (i-1)*1.2))
}

for (i in 1:4) {
    mtext("M&NEM", side = 3, line = 44.3, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.5 - (i-1)*1.2))
}

for (i in 1:4) {
    mtext(expression(sigma), side = 3, line = -12, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.1 - (i-1)*1.2))
}
```
```{r, fig.height=12, fig.width=12, fig.cap=fig.cap3}
mar <- 1.5

par(mfrow=c(5,4),mar=rep(mar, 4),oma=c(3,5,3,0))

for (i in 1:5) {
    for (j in c(3,5,10,20)) {
        tmp <- get(paste0("simres", j))
        tmp2 <- NULL
        for (l in 1:3) {
            tmp3 <- tmp[,l,i,1,2]
            tmp2 <- cbind(tmp2, tmp3)
        }
        boxplot(tmp2, col = rep(redcol, 3), xaxt = "n")
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol)
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol2, pch = "*")
        axis(1, 1:(length(noises)*3), rep(noises, 3))
        abline(h=1, lty = 3, col = "black", lwd = 2)
    }
}

for (i in 1:5) {
    mtext(paste0("K=", i), side = 3, line = (40 - (i-1)*11.1), outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*4)
}

Sgenes <- c(3,5,10,20)

for (i in 1:4) {
    mtext(paste0("n=", Sgenes[i]), side = 3, line = 46, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.2 - (i-1)*1.2))
}

for (i in 1:4) {
    mtext(expression(sigma), side = 3, line = -12, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.15 - (i-1)*1.21))
}
```
```{r, fig.height=12, fig.width=12, fig.cap=fig.cap4}
par(mfrow=c(5,4),mar=rep(mar, 4),oma=c(3,5,3,0))

for (i in 1:5) {
    for (j in c(3,5,10,20)) {
        tmp <- get(paste0("simres", j))
        tmp2 <- NULL
        for (l in 1:3) {
            tmp2 <- cbind(tmp2, tmp3)
        }
        boxplot(tmp2, col = rep(redcol, 3), xaxt = "n")
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol)
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol2, pch = "*")
        axis(1, 1:(length(noises)*3), rep(noises, 3))
        abline(h=1, lty = 3, col = "black", lwd = 2)
    }
}

for (i in 1:5) {
    mtext(paste0("K=", i), side = 3, line = (40 - (i-1)*11.1), outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*4)
}

Sgenes <- c(3,5,10,20)

for (i in 1:4) {
    mtext(paste0("n=", Sgenes[i]), side = 3, line = 46, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.2 - (i-1)*1.2))
}

for (i in 1:4) {
    mtext(expression(sigma), side = 3, line = -12, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.15 - (i-1)*1.21))
}
```

## Application

We apply M&NEM to three different data sets from two different pooled CRISPR screens, Crop-Seq (Datlinger **et al.**, 2017) and Perturb-Seq (Dixit **et al.**, 2016).

```{r}

```

# Session information

```{r}
sessionInfo()
```
