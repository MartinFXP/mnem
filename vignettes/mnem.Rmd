---
title: "Mixture Nested Effects Models  \n
Inferring networks from sub-populations of single cells."
author: "Martin Pirkl, Niko Beerenwinkel"
date: "`r Sys.Date()`"
graphics: yes
output: BiocStyle::pdf_document
vignette: >
    %\VignetteIndexEntry{mnem}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

# Mixture Nested Effects Models (M&NEM)

Single cell RNA-seq data sets from pooled CrispR screens provide the possibility to analyzse heterogeneous cell populations. We extended the original Nested Effects Models (NEM) to Mixture Nested Effects Models (M&NEM) to identify not one causal signalling, but several ones, each based on the information of a sub-population of cells.

## Install

Download and install the package manually or use 'devtools'.

```{r, global_options, include=FALSE}
knitr::opts_chunk$set(message=FALSE)
fig.cap1 <- "Accuracy of the networks and number of components."
fig.cap2 <- "Accuracy of the networks."
fig.cap3 <- "Accuracy for number of components. Greater than 1 means too many were inferred. Less than 1 means to few."
fig.cap4 <- "Distance of inferred to ground truth mixture weights."
```
```{r}
library(mnem)
```
  
## Simulations

We simulate cells based on a ground truth mixture of networks. We use M&NEM to infer an optimal network from the data and compare the result ot the ground truth.

```{r}
runs <- 100
noises <- c(1, 2.5, 5)

acc <- comps <- mws <- numeric(runs)

Sgenes <- 5
Egenes <- 2
nem <- 2
maxk <- 5
starts <- 10
noise <- 1
nCells <- 1000
```
```{r, eval = FALSE}
for (run in 1:length(acc)) {
    mw <- runif(nem, 0.1, 1)
    mw <- mw/sum(mw)
    sim <- simData(Sgenes = Sgenes, Egenes = Egenes, nCells = nCells,
                   Nems = nem, uninform = floor(Egenes*Sgenes*0.1), mw = mw)
    simfull <- NULL
    gtn <- list()
    for (i in 1:length(sim$Nem)) {
        tmp <- transitive.closure(sim$Nem[[i]], mat = TRUE)
        simfull <- cbind(simfull, t(tmp))
        gtn[[i]] <- list()
        gtn[[i]]$adj <- sim$Nem[[i]]
    }
    
    data <- sim$data
    data <- (data - 0.5)/0.5
    data <- data + rnorm(length(sim$data), 0, noises[noise])
    for (i in 1:Sgenes) {
        colnames(data)[which(colnames(data) == i)] <- letters[i]
    }

    start <- Sys.time()
    res2 <- list()
    bics <- rep(Inf, maxk)
    for (k in 1:maxk) {
        res2[[k]] <- mnem(data, starts = starts, k = k)
        bics[k] <- getIC(res2[[k]])
    }
    res <- res2[[which.min(bics)]]
    end <- Sys.time()
    print(end - start)
    comps[run] <- which.min(bics)
    
    resfull <- NULL
    for (i in 1:length(res$comp)) {
        tmp <- transitive.closure(res$comp[[i]]$phi, mat = TRUE)
        resfull <- cbind(resfull, t(tmp))
    }
    
    resadj <- list()
    for (i in 1:length(res$comp)) {
        resadj[[i]] <- list()
        resadj[[i]]$adj <- res$comp[[i]]$phi
    }
    acc[run] <- hamSim(resfull, simfull, symmetric = TRUE)
}
par(mfrow=c(1,2)
plot(acc)
plot(comps)    
```

We randomly draw mixture weights as a comparison to our inferred weights.
	
```{r, warning=FALSE, fig.cap="Distance between groudn truth and random mixture weights for different numbers of components."}
runs <- 100
maxk <- 5
mixrand <- matrix(0, runs, maxk)
for (j in 1:5) {
    nem <- j
    tmp <- numeric(runs)
    for (i in 1:runs) {
        mw <- runif(nem, 0.1, 1)
        mw <- mw/sum(mw)
        nem2 <- sample(1:5, 1)
        mw2 <- runif(nem2, 0.1, 1)
        mw2 <- mw2/sum(mw2)
        tmp[i] <- dist(rbind(mw, mw2))
    }
    mixrand[, j] <- tmp
}

boxplot(mixrand, col = "grey", main = "random", xlab = "components K")
```
	
Evaluation of the simulation results by accuracy of the networks, mixture weights and number of components.

```{r, fig.height=8, fig.width=10, fig.cap=fig.cap2}
data(sim)

simres3 <- sim[[1]]
simres5 <- sim[[2]]
simres10 <- sim[[3]]
simres20 <- sim[[4]]
  
meancol2 <- rgb(1,0,0)

meancol <- rgb(0,0,1)

redcol <- rgb(1,0,0)

bluecol <- rgb(0,0,1)

mar <- 1.5

par(mfrow=c(5,4),mar=rep(mar, 4),oma=c(3,5,3,0))

for (i in 1:5) {
    for (j in c(3,5,10,20)) {
        tmp <- get(paste0("simres", j))
        tmp2 <- NULL
        for (k in c(1,2)) {
            for (l in 1:3) {
                tmp3 <- tmp[,l,i,k,3]
                tmp2 <- cbind(tmp2, tmp3)
            }
        }
        boxplot(tmp2, col = c(rep(redcol, 3), rep(bluecol, 3), rep("grey", 3)), xaxt = "n", ylim = c(0.5,1))
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol)
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol2, pch = "*")
        axis(1, 1:(length(noises)*3), rep(noises, 3))
        abline(v=c(length(noises)+0.5), lty = 3, col = "black", lwd = 2)
    }
}

for (i in 1:5) {
    mtext(paste0("K=", i), side = 3, line = (40 - (i-1)*11.1), outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*4)
}

Sgenes <- c(3,5,10,20)

for (i in 1:4) {
    mtext(paste0("n=", Sgenes[i]), side = 3, line = 46, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.2 - (i-1)*1.2))
}

for (i in 1:4) {
    mtext("NEM", side = 3, line = 44.3, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(2.97 - (i-1)*1.2))
}

for (i in 1:4) {
    mtext("M&NEM", side = 3, line = 44.3, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.5 - (i-1)*1.2))
}

for (i in 1:4) {
    mtext(expression(sigma), side = 3, line = -12, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.1 - (i-1)*1.2))
}
```
```{r, fig.height=8, fig.width=10, fig.cap=fig.cap3}
mar <- 1.5

par(mfrow=c(5,4),mar=rep(mar, 4),oma=c(3,5,3,0))

for (i in 1:5) {
    for (j in c(3,5,10,20)) {
        tmp <- get(paste0("simres", j))
        tmp2 <- NULL
        for (l in 1:3) {
            tmp3 <- tmp[,l,i,1,2]
            tmp2 <- cbind(tmp2, tmp3)
        }
        boxplot(tmp2, col = rep(redcol, 3), xaxt = "n")
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol)
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol2, pch = "*")
        axis(1, 1:(length(noises)*3), rep(noises, 3))
        abline(h=1, lty = 3, col = "black", lwd = 2)
    }
}

for (i in 1:5) {
    mtext(paste0("K=", i), side = 3, line = (40 - (i-1)*11.1), outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*4)
}

Sgenes <- c(3,5,10,20)

for (i in 1:4) {
    mtext(paste0("n=", Sgenes[i]), side = 3, line = 46, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.2 - (i-1)*1.2))
}

for (i in 1:4) {
    mtext(expression(sigma), side = 3, line = -12, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.15 - (i-1)*1.21))
}
```
```{r, fig.height=8, fig.width=10, fig.cap=fig.cap4}
par(mfrow=c(5,4),mar=rep(mar, 4),oma=c(3,5,3,0))

for (i in 1:5) {
    for (j in c(3,5,10,20)) {
        tmp <- get(paste0("simres", j))
        tmp2 <- NULL
        for (l in 1:3) {
            tmp2 <- cbind(tmp2, tmp3)
        }
        boxplot(tmp2, col = rep(redcol, 3), xaxt = "n")
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol)
        lines(1:ncol(tmp2), apply(tmp2, 2, mean), type = "p", col = meancol2, pch = "*")
        axis(1, 1:(length(noises)*3), rep(noises, 3))
        abline(h=1, lty = 3, col = "black", lwd = 2)
    }
}

for (i in 1:5) {
    mtext(paste0("K=", i), side = 3, line = (40 - (i-1)*11.1), outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*4)
}

Sgenes <- c(3,5,10,20)

for (i in 1:4) {
    mtext(paste0("n=", Sgenes[i]), side = 3, line = 46, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.2 - (i-1)*1.2))
}

for (i in 1:4) {
    mtext(expression(sigma), side = 3, line = -12, outer = FALSE, cex = 1, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*(3.15 - (i-1)*1.21))
}
```

## Application

We apply M&NEM to three different data sets from two different pooled CRISPR screens, Crop-Seq (Datlinger **et al.**, 2017) and Perturb-Seq (Dixit **et al.**, 2016).

```{r, eval=FALSE}

load("bics.rda")

maxk <- length(res)

source("mnem/R/mnems.r")
source("mnem/R/mnems_low.r")
library(graph)
library(nem)
library(Rgraphviz)
library(epiNEM)
library(naturalsort)

pdf("PLR.pdf", width = 11, height = 3)
    
par(mfrow=c(1,3), oma = c(0,0,1,0), mar = rep(0,4))

for (j in 1:3) {

    res <- res2[[j]]
    
    bics <- rep(0, maxk)
    
    ll <- rep(0, maxk)
    
    for (i in 1:maxk) {
        
        bics[i] <- getIC(res[[i]], useF = F, Fnorm = T)
        
        ll[i] <- max(res[[i]]$ll)

    }

    bicsall[[j]] <- bics

    llall[[j]] <- ll
    
    ll2 <- ll
    
    ll <- (ll/(max(ll)-min(ll)))*(max(bics)-min(bics))
    
    ll <- ll - min(ll) + min(bics)
    
    ll3 <- seq(min(bics), max(bics[!is.infinite(bics)]), length.out = 5)
    
    if (length(grep("perturbseq", dataset)) != 0) {
        bigorsmall <- ""
    } else {
        bigorsmall <- paste0("_", bigorsmall)
    }
    
    par(mar=c(5,5,2,5))
    plot(bics, type = "b", ylab = "", col = "red", xlab = "", yaxt = "n", ylim = c(min(min(bics,ll)), max(max(bics,ll))), xaxt = "n")
    lines(ll, type = "b", col = "blue")
    axis(4, ll3, round(seq(min(ll2), max(ll2), length.out = 5)), cex.axis = 1.7)
    axis(2, ll3, round(ll3), cex.axis = 1.7)
    axis(1, 1:maxk, 1:maxk)
    mtext("penalized", side=2, line=3, cex = 1.2)
    mtext("raw", side=4, line=3, cex = 1.2)
    
    mtext(LETTERS[j], side = 3, line = -1, outer = FALSE, cex = 2.5, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*0.27)

}

dev.off()

pdf("PLR_legend.pdf", height = 4, width = 5)

plot(0, xlim = c(0,100), ylim = c(0,100))

legend(0, 100, c("raw log likelihood ratio", "penalized log likelihood ratio"), fill = ,
       border = "transparent", cex = 1.25, lty = 1, pch = 1, col = c("blue", "red"))

dev.off()

i <- which.min(bics)

gamma <- getAffinity(res[[i]]$probs, mw = res[[i]]$mw)

## HeatmapOP(gamma, breaks = 100, bordercol = "transparent")

## histograms:

pdf("histograms.pdf", width = 11, height = 3)
    
par(mfrow=c(1,3), oma = c(0,0,1,0), mar = rep(0,4))

for (j in 1:3) {

    res <- res2[[j]]
    
    bics <- rep(0, maxk)
    
    ll <- rep(0, maxk)
    
    for (i in 1:maxk) {
        
        bics[i] <- getIC(res[[i]], useF = F, Fnorm = T)
        
        ll[i] <- max(res[[i]]$ll)

    }

    ll2 <- ll
    
    ll <- (ll/(max(ll)-min(ll)))*(max(bics)-min(bics))
    
    ll <- ll - min(ll) + min(bics)
    
    ll3 <- seq(min(bics), max(bics[!is.infinite(bics)]), length.out = 5)
    
    if (length(grep("perturbseq", dataset)) != 0) {
        bigorsmall <- "" # for perturbseq
    } else {
        bigorsmall <- paste0("_", bigorsmall)
    }
    
    i <- which.min(bics)

    gamma <- getAffinity(res[[i]]$probs, mw = res[[i]]$mw)

    par(mar=c(5,5,2,5))
    hist(gamma, main = "Histogram of responsibilities", xlab = "responsibilities")
    
    mtext(LETTERS[j], side = 3, line = -2.3, outer = FALSE, cex = 2.5, adj = 0,
          at = par("usr")[1] - (par("usr")[2]-par("usr")[1])*0.27)

}

dev.off()

pdf(paste0(gsub("perturbseq_", "", dataset), bigorsmall, "_hist.pdf"), width = 5, height = 5)

hist(gamma, main = "Histogram of responsibilities", xlab = "responsibilities")

dev.off()

i <- which.min(bics)

pdf(paste0(gsub("perturbseq_", "", dataset), bigorsmall, "_gamma.pdf"), width = 30, height = 10)

gamma <- getAffinity(res[[i]]$probs, mw = res[[i]]$mw)

HeatmapOP(gamma, breaks = 100, bordercol="transparent", cexCol = 0.4, xrot = 45, Rowv = F)

dev.off()

pdf(paste0(gsub("perturbseq_", "", dataset), bigorsmall, "_network.pdf"), width = 30, height = 10)

plot(res[[i]])

dev.off()

pdf(paste0(gsub("perturbseq_", "", dataset), bigorsmall, "_network_overfit.pdf"), width = 30, height = 10)

plot(res[[(i+1)]])

dev.off()

if (length(grep("cc7d", dataset)) == 0) {
    pdf(paste0(gsub("perturbseq_", "", dataset), bigorsmall, "_network_wo.pdf"), width = 10, height = 7)
} else {
    pdf(paste0(gsub("perturbseq_", "", dataset), bigorsmall, "_network_wo.pdf"), width = 14, height = 14) # cc7d
}

plot(res[[i]], egenes = F, bestCell=F, cells = F, showweights = F)

dev.off()

if (length(grep("p7d", dataset)) == 1) {
    pdf(paste0(gsub("perturbseq_", "", dataset), bigorsmall, "_network_overfit_wo.pdf"), width = 8, height = 5)
    plot(res[[(i+1)]], egenes = F, bestCell=F, cells = F, showweights = F)
    dev.off()
}

if (length(grep("cc7d", dataset)) == 1) {
    pdf(paste0(gsub("perturbseq_", "", dataset), bigorsmall, "_network_overfit_wo.pdf"), width = 11.5, height = 8.5)
    plot(res[[(i+1)]], egenes = F, bestCell=F, cells = F, showweights = F)
    dev.off()
}

pdf(paste0(gsub("perturbseq_", "", dataset), bigorsmall, "_kegg.pdf"), width = 10, height = 10)

plot.adj(kadjagg)

dev.off() 
```

# Data generation
  
```{r, eval=FALSE}
data <- read.csv("GSE92872_CROP-seq_Jurkat_TCR.digital_expression.csv", stringsAsFactors = FALSE)

counts <- data[, grep("condition|^stim", colnames(data))]

counts <- counts[-(1:5), -1]

counts <- matrix(as.numeric(as.character(unlist(counts))), nrow(counts))

rownames(counts) <- data[6:nrow(data), 1]

colnames(counts) <- data[4, grep("^stim", colnames(data))]

colnames(counts)[which(colnames(counts) %in% "CTRL")] <- ""

data <- data[, -grep("DHODH|MVD|TUBB", colnames(data))]

save(data, file = "data.rda")

library(data.table)

data <- fread("k562_both_filt.txt")

data.backup <- data

data <- data[, -1]

data <- as.matrix(data)

rownames(data) <- data.backup$GENE

## data <- data[, grep("p7d", colnames(data))]

## data <- data[, grep("cc7d", colnames(data))]

## c2g <- read.csv("data/perturbseq/GSE90063_RAW/GSM2396858_k562_tfs_7_cbc_gbc_dict.csv", header = FALSE)

## c2g <- read.csv("data/perturbseq/GSE90063_RAW/GSM2396861_k562_ccycle_cbc_gbc_dict.csv", header = FALSE)

cn <- character(ncol(data))

for (i in 1:length(c2g[[1]])) {
    
    cells <- unlist(strsplit(as.character(c2g[[2]][[i]]), ", "))
    
    cn[which(colnames(data) %in% cells)] <- paste(cn[which(colnames(data) %in% cells)],
                                                       gsub("^c_|^c_sg|^m_|_[0-9]$|_10$", "", as.character(c2g[[1]][[i]])), sep = "_")

}

colnames(data) <- gsub("^_|^_p_sg|^_p_", "", cn)

data <- data[, -which(colnames(data) %in% "")]

pertdist <- unlist(lapply(colnames(data), function(x) return(length(unlist(strsplit(x, "_"))))))

hist(pertdist)

if (length(grep("_", colnames(data))) > 0) {
    data <- data[, -grep("_", colnames(data))]
}

save(data, file = "data.rda")

## job script for simulations:

args <- commandArgs()
Sgenes <- as.numeric(gsub("Sgenes=", "", args[grep("Sgenes=", args)]))
run <- gsub("run=", "", args[grep("run=", args)])
noise <- gsub("noise=", "", args[grep("noise=", args)])
nem <- gsub("nem=", "", args[grep("nem=", args)])

# nem <- 1:5; noise <- 1:3; run <- 1; Sgenes <- 3

if (length(grep(":", nem)) > 0) {
    nem <- as.numeric(gsub(":.*", "", nem)):as.numeric(gsub(".*:", "", nem))
} else {
    nem <- as.numeric(nem)
}

if (length(grep(":", noise)) > 0) {
    noise <- as.numeric(gsub(":.*", "", noise)):as.numeric(gsub(".*:", "", noise))
} else {
    noise <- as.numeric(noise)
}

if (length(grep(":", run)) > 0) {
    run <- as.numeric(gsub(":.*", "", run)):as.numeric(gsub(".*:", "", run))
} else {
    run <- as.numeric(run)
}

library(cluster)
library(nem)
library(snowfall)
library(Rgraphviz)
library(mnem)

start1 <- as.numeric(format(Sys.time(), "%s"))

## variable parameters:
runs <- 100
noises <- c(1, 2.5, 5, 10)
nems <- 1:10
maxk <- 5

## fixed parameters:
starts <- 10
search <- "modules"
verbose <- FALSE

## mixing parameters:
Egenes <- 2
nCells <- 1000

simres <- array(0, c(runs, length(noises), length(nems), 4, 7), list(paste("run_", 1:runs, sep = ""), paste("noise_", noises, sep = ""), paste("components_", nems, sep = ""), c("mnem", "nem", "random", "random2"), c("time", "overfit", "accuracy", "sensitivity", "specificity", "mixing", "mixing2")))

for (i in nem) {
    for (j in noise) {    
        if (file.exists(paste("temp/simres_mnem_", Sgenes, "_", run, "_", j, "_", i, ".rda", sep = ""))) {
            print(paste("temp/simres_mnem_", Sgenes, "_", run, "_", j, "_", i, ".rda", sep = ""))
            stop("simulation result already exists")
        }
    }
}

for (donoise in noise) {
    for (donem in nem) {

        ## donoise <- noise[1]; donem <- nem[2]

        print(paste(rep("_", 100), collapse = ""))
        print(paste("run", run))
        print(paste("noise", noises[donoise]))
        print(paste("nems", nems[donem]))
 
        mw <- runif(nems[donem], 0.1, 1)
        mw <- mw/sum(mw)
        sim <- simData(Sgenes = Sgenes, Egenes = Egenes, nCells = nCells,
                       Nems = nems[donem],
                       mw = mw, uninform = floor(Sgenes*Egenes*0.1))
        simfull <- NULL
        fullsim <- sim$Nem[[1]]*0
        for (i in 1:length(sim$Nem)) {
            tmp <- transitive.closure(sim$Nem[[i]], mat = TRUE)
            simfull <- cbind(simfull, t(tmp))
            fullsim <- fullsim + transitive.closure(sim$Nem[[i]], mat = TRUE)
        }
        fullsim[which(fullsim > 1)] <- 1
        diag(fullsim) <- 1
        
        ## mnem:
        data <- sim$data
        data <- (data - 0.5)/0.5
        data <- data + rnorm(length(sim$data), 0, noises[donoise])
        ## random p:
        p <- NULL
        start <- as.numeric(format(Sys.time(), "%s"))
        res <- list()
        if (maxk == 1) {
            res <- mnem(data, starts = starts, search = search, verbose = verbose)
        } else {
            bics <- rep(Inf, maxk)
            for (k in 1:maxk) {
                res[[k]] <- mnem(data, starts = starts, search = search, k = k, verbose = verbose)
                bics[k] <- getIC(res[[k]])
            }
            res1 <- res[[1]]
            res <- res[[which.min(bics)]]
        }
        simres[run, donoise, donem, 1, 1] <- as.numeric(format(Sys.time(), "%s")) - start
        resfull <- NULL
        fullres <- res$comp[[1]]$phi*0
        for (i in 1:length(res$comp)) {
            tmp <- transitive.closure(res$comp[[i]]$phi, mat = TRUE)
            resfull <- cbind(resfull, t(tmp))
            fullres <- fullres + transitive.closure(res$comp[[i]]$phi, mat = TRUE)
        }
        fullres[which(fullres > 1)] <- 1
        diag(fullres) <- 1

        ## look at binary mixing weights:
        if (dim(res$probs)[1] == 1) {
            mwbin <- 1
        } else {
            mwbin <- apply(apply(getAffinity(res$probs, mw = res$mw,affinity=0), 2,
                                 function(x) { xmax <- max(x)
                                     x[which(x != xmax)] <- 0
                                     x[which(x != 0)] <- 1
                                     return(x) }),
                           1, sum)/ncol(res$probs)
        }
        
        simres[run, donoise, donem, 1, 2] <- length(res$comp)/nems[donem]
        tp <- sum(fullres == 1 & fullsim == 1) - ncol(fullres)
        tn <- sum(fullres == 0 & fullsim == 0)
        fp <- sum(fullres == 1 & fullsim == 0)
        fn <- sum(fullres == 0 & fullsim == 1)
        simres[run, donoise, donem, 1, 4] <- tp/(tp+fn)
        simres[run, donoise, donem, 1, 5] <- tn/(tn+fp)
        simres[run, donoise, donem, 1, 3] <- hamSim(simfull, resfull)
        if (length(mw) == length(res$mw)) {
            simres[run, donoise, donem, 1, 6] <- sum(dist(rbind(sort(res$mw), sort(mw))))
            simres[run, donoise, donem, 1, 7] <- sum(dist(rbind(sort(mwbin), sort(mw))))
        }
        if (length(mw) > length(res$mw)) {
            simres[run, donoise, donem, 1, 6] <- sum(dist(rbind(sort(c(res$mw, rep(0, length(mw) - length(res$mw)))), sort(mw))))
            simres[run, donoise, donem, 1, 7] <- sum(dist(rbind(sort(c(mwbin, rep(0, length(mw) - length(mwbin)))), sort(mw))))
        }
        if (length(mw) < length(res$mw)) {
            simres[run, donoise, donem, 1, 6] <- sum(dist(rbind(sort(c(mw, rep(0, length(res$mw) - length(mw)))), sort(res$mw))))
            simres[run, donoise, donem, 1, 7] <- sum(dist(rbind(sort(c(mw, rep(0, length(mwbin) - length(mw)))), sort(mwbin))))
        }
        
        ## nem:
        start <- as.numeric(format(Sys.time(), "%s"))
        nemres <- mynem(data, search = search)
        simres[run, donoise, donem, 2, 1] <- as.numeric(format(Sys.time(), "%s")) - start
        if (maxk == 1) {
            fullnem <- transitive.closure(nemres$adj, mat = TRUE)
        } else {
            fullnem <- transitive.closure(res1$comp[[1]]$phi, mat = TRUE)
        }
        diag(fullnem) <- 1

        simres[run, donoise, donem, 2, 2] <- 1/nems[donem]
        tp <- sum(fullnem == 1 & fullsim == 1) - ncol(fullnem)
        tn <- sum(fullnem == 0 & fullsim == 0)
        fp <- sum(fullnem == 1 & fullsim == 0)
        fn <- sum(fullnem == 0 & fullsim == 1)
        simres[run, donoise, donem, 2, 4] <- tp/(tp+fn)
        simres[run, donoise, donem, 2, 5] <- tn/(tn+fp)
        simres[run, donoise, donem, 2, 3] <- hamSim(simfull, t(fullnem))
        simres[run, donoise, donem, 2, 6] <- sum(dist(rbind(sort(c(1, rep(0, length(mw) - 1))), sort(mw))))
        
        ## random:
        fullrand <- matrix(sample(c(0,1), Sgenes^2, replace = TRUE), Sgenes, Sgenes)
        diag(fullrand) <- 1
        rownames(fullrand) <- colnames(fullrand) <- 1:Sgenes
        
        simres[run, donoise, donem, 4, 2] <- 1/nems[donem]
        tp <- sum(fullrand == 1 & fullsim == 1) - ncol(fullrand)
        tn <- sum(fullrand == 0 & fullsim == 0)
        fp <- sum(fullrand == 1 & fullsim == 0)
        fn <- sum(fullrand == 0 & fullsim == 1)
        simres[run, donoise, donem, 4, 4] <- tp/(tp+fn)
        simres[run, donoise, donem, 4, 5] <- tn/(tn+fp)
        simres[run, donoise, donem, 4, 3] <- hamSim(simfull, fullrand)
        simres[run, donoise, donem, 4, 6] <-  sum(dist(rbind(sort(c(1, rep(0, length(mw) - 1))), sort(mw))))
        
    }
}

end1 <- as.numeric(format(Sys.time(), "%s"))

print(end1 - start1)

for (i in nem) {
    for (j in noise) {    
        save(simres, noises, nems, file = paste("temp/simres_mnem_", Sgenes, "_", run, "_", j, "_", i, ".rda", sep = ""))
    }
}

stop("simulations are done")

### job script to turn normalized count data in log likelihood ratios and apply mnem.

library(mnem)
library(cluster)
library(nem)
library(Rgraphviz)

## define dataset

#dataset <- "cropseq"

#dataset <- "perturbseq_cc7d"

#dataset <- "perturbseq_p7d"

args <- commandArgs()

dataset <- gsub("dataset=", "", args[grep("dataset=", args)])

parallel <- gsub("cores=", "", args[grep("cores=", args)])

starts <- gsub("starts=", "", args[grep("starts=", args)])

run <- gsub("run=", "", args[grep("run=", args)])

dollr <- as.numeric(gsub("dollr=", "", args[grep("dollr=", args)]))

dobig <- as.numeric(gsub("dobig=", "", args[grep("dobig=", args)]))

dosmall <- as.numeric(gsub("dosmall=", "", args[grep("dosmall=", args)]))

addendum <- paste0("_run", run)

library(snowfall)

maxk <- 5

print(dataset)
print(dobig)
print(dosmall)
print(dollr)

####################################### perturb-seq and crop-seq log likelihood ratio:

if (dollr) {

    load(paste0(dataset, "_data.rda"))

    if (length(grep("perturbseq", dataset)) == 0) {

        exprslvl <- apply(data, 1, median)
        
        data <- data[which(exprslvl > 0), ]

        data <- t(t(data)/(colSums(data)/10000))

        data <- log2(data + 0.5)
    
    } else {

        data <- exp(data) - 1

        exprslvl <- apply(data, 1, median)
        
        data <- data[which(exprslvl > 0), ]

        if (length(grep("p7d|cc7d", dataset)) > 0) {

            colnames(data)[grep("INTER", colnames(data))] <- ""

        }

        data <- log2(data + 0.5)

    }

    llr <- data*0

    C <- which(colnames(data) %in% "")

    distrPar <- function(i, data, C) {
        llrcol <- numeric(ncol(data))
        for (j in which(!(colnames(data) %in% ""))) {
            gene <- colnames(data)[j]
            D <- which(colnames(data) %in% gene)
            cdistr <- ecdf(data[i, C])
            ddistr <- ecdf(data[i, D])
            llrcol[j] <- log2(min(ddistr(data[i, j]), 1 - ddistr(data[i, j]))/min(cdistr(data[i,j]), 1 - cdistr(data[i,j])))
        }
        return(llrcol)
    }

    sfInit(parallel = TRUE, cpus = parallel)
    llr <- sfLapply(1:nrow(data), distrPar, data, C)
    llr <- do.call("rbind", llr)
    sfStop()

    llr[is.na(llr)] <- 0

    llr[is.infinite(llr)] <- max(llr[!is.infinite(llr)])

    colnames(llr) <- colnames(data)

    llr <- llr[, which(!(colnames(data) %in% ""))] # !!!

    rownames(llr) <- rownames(data)

    save(llr, file = paste0(dataset, "_llr.rda"))

    print("llr done")

}

## stop()

########### do small set of genes:

if (dosmall) {

    load(paste0(dataset, "_kegg.rda"))
    load(paste0(dataset, "_llr.rda"))

    if (length(grep("perturbseq", dataset)) == 0) {

        llr <- llr[, -grep("DHODH|MVD|TUBB", colnames(llr))]


    }

    llr <- t(apply(llr, 1, function(x) {
        x[is.infinite(x)] <- max(x[!is.infinite(x)])
        return(x)
    }))

    colnames(llr) <- toupper(colnames(llr))

    if (length(grep("perturbseq", dataset)) == 0) {

        cropgenes <- c("LCK", "ZAP70", "PTPN6", "DOK2", "PTPN11", "EGR3", "LAT")
        
        lods <- llr[, which(colnames(llr) %in% cropgenes)]
        
    } else {
        
        lods <- llr
        
    }

    badgenes <- "Tcrlibrary"
    badgenes <- grep(badgenes, rownames(lods))

    if (length(badgenes) > 0) {
        lods <- lods[-badgenes, ]
    }

    sdev <- apply(lods, 1, sd)

    lods <- lods[which(sdev > sd(lods)), ]

    n <- length(unique(colnames(lods)))

    lods <- lods

    bics <- rep(Inf, maxk)

    res <- list()
    
    for (k in 1:maxk) {

        res[[k]] <- mnem(lods, starts = starts, type = "random", parallel = parallel, k = k, verbose = TRUE, converged = 10^-1, search = "modules")
        
        res[[k]]$data <- NULL
        
        save(res, file = paste0("cropseq/", dataset, "_mnem_small", addendum, ".rda"))
        
    }
    
    save(res, file = paste0("cropseq/", dataset, "_mnem_small", addendum, ".rda"))

    stop("small set done")

}

###########################################

stop()

## rm *.sh.*

## ## code to run the job script on hpc:

## module load repo/grid
## module load grid/grid

## for i in `seq 1 100`; do
##     cores=1
##     file=${i}.sh
##     echo "module load repo/grid" >> $file
##     echo "module load grid/grid" >> $file
##     echo "module load R/3.4.0" >> $file
##     echo "R --slave --args 'dataset=perturbseq_p7d' 'cores=$cores' 'run=$i' 'starts=1' 'dollr=0' 'dobig=1' 'dosmall=0' < mnem/vignettes/job.R" >> $file
##     qsub -q mpi01.q -pe make $cores $file
##     rm $file
## done

## module load r/3.4.0

## for i in `seq 2 100`; do
##     cores=1
##     file=Withsomeluck${i}.sh
##     echo "R --slave --args 'dataset=cropseq' 'cores=$cores' 'run=$i' 'starts=1' 'dollr=0' 'dobig=1' 'dosmall=0' < mnem/vignettes/job.R" >> $file
##     bsub -M 10000 -q normal.24h -n 1 -e logs/${file}_${i}_error.txt -o logs/${file}_${i}_output.txt < $file
##     rm $file
## done

## get the best for several on one core each:

maxk <- 5

starts <- 100

dataset <- "cropseq"

#dataset <- "perturbseq_cc7d"

#dataset <- "perturbseq_p7d"

bigorsmall <- "small"

lls <- matrix(0, 5, starts)

llmins <- matrix(0, 5, starts)

resMax <- list()

for (i in 1:starts) {
    print(i)
    if (file.exists(paste0("cropseq/", dataset, "_mnem_", bigorsmall, "_run", i, ".rda"))) {
        load(paste0("cropseq/", dataset, "_mnem_", bigorsmall, "_run", i, ".rda"))
    } else {
        next()
    }
    lls[1, i] <- res[[1]]$ll
    for (j in 1:min(maxk, length(res))) {
        lls[j, i] <- res[[j]]$ll
        llmins[j, i] <- min(res[[j]]$limits[[1]]$ll)
        if (i == 1 | length(resMax) < j) {
            resMax[[j]] <- res[[j]]
        } else {
            if (resMax[[j]]$ll < res[[j]]$ll) {
                resMax[[j]] <- res[[j]]
            }
        }
    }
}

## load log odds before next step

res <- resMax

res[[5]]$data <- res[[4]]$data <- res[[3]]$data <- res[[2]]$data <- res[[1]]$data <- lods


## save(res, file = paste0(dataset, "_mnem_", bigorsmall, "_final.rda"))

load(paste0(dataset, "_mnem_", bigorsmall, "_final.rda"))

cropres <- res

cc7dres <- res

p7dres <- res

res2 <- list(cropres, cc7dres, p7dres)

```
	
# Session information

```{r}
sessionInfo()
```

## References:
   
Martin Pirkl, Niko Beerenwinkel (2018).  
Single cell network analysis with a mixture of Nested Effects Models  
bioRxiv 258202; doi: https://doi.org/10.1101/258202  

Datlinger, P., Rendeiro, A., Schmidl, C., Krausgruber, T., Traxler, P., Klughammer, J., Schuster, L. C., Kuchler, A., Alpar, D., and Bock, C. (2017).  
Pooled crispr screening with single-cell transcriptome readout.  
Nature Methods, 14, 297 EP –.

Dixit, A., Parnas, O., Li, B., Chen, J., Fulco, C. P., Jerby-Arnon, L., Marjanovic, N. D., Dionne, D., Burks, T., Raychowdhury, R., Adamson, B., Norman, T. M., Lander, E. S., Weissman, J. S., Friedman, N., and Regev, A. (2016).  
Perturb-seq: Dissecting molecular circuits with scalable single-cell rna profiling of pooled genetic screens.  
Cell, 167(7), 1853–1866.e17.
